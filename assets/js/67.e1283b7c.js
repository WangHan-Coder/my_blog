(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{490:function(t,e,v){"use strict";v.r(e);var _=v(1),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("vue提供了两种编译版本，一种是"),e("code",[t._v("Runtime-Compiler")]),t._v("，还有一种是"),e("code",[t._v("Runtime-only")]),t._v("，前者会多提供"),e("code",[t._v("compiler")]),t._v("功能，也就是支持"),e("code",[t._v("template")]),t._v("写法。也就是我们可以在组件对象中写"),e("code",[t._v("template:<div>"+t._s(t.a)+"</div>")]),t._v("，然后vue内部会把template转化为"),e("code",[t._v("render函数")]),t._v("，这个过程就是"),e("code",[t._v("模板编译")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"模板编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板编译"}},[t._v("#")]),t._v(" 模板编译")]),t._v(" "),e("h3",{attrs:{id:"原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),e("ul",[e("li",[t._v("模板不是html，有指令、插值、JS表达式，能实现判断、循环")]),t._v(" "),e("li",[t._v("html是标签语言，只有JS才能实现判断、循环（图灵完备的，能实现我们日常的业务逻辑，能实现顺序执行、循环和判断）")]),t._v(" "),e("li",[t._v("因此，模板一定是转换为某种JS代码，即模板编译")])]),t._v(" "),e("h3",{attrs:{id:"过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),e("ul",[e("li",[t._v("width语法")]),t._v(" "),e("li",[t._v("vue template complier将模板编译为render函数")]),t._v(" "),e("li",[t._v("执行render函数生成vnode")]),t._v(" "),e("li",[t._v("基于vnode再执行patch和diff")]),t._v(" "),e("li",[t._v("使用vue-loader，会在开发环境下编译模板")])]),t._v(" "),e("h2",{attrs:{id:"初次渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初次渲染"}},[t._v("#")]),t._v(" 初次渲染")]),t._v(" "),e("ul",[e("li",[t._v("initState数据劫持，添加getter和setter")]),t._v(" "),e("li",[t._v("挂载时将模板编译成render函数（或在开发环境下用vue-loader完成）")]),t._v(" "),e("li",[t._v("调用render函数生成vdom，收集依赖")]),t._v(" "),e("li",[t._v("patch(elm, vnode)渲染到页面上")])]),t._v(" "),e("h2",{attrs:{id:"更新流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新流程"}},[t._v("#")]),t._v(" 更新流程")]),t._v(" "),e("ul",[e("li",[t._v("修改数据，触发setter")]),t._v(" "),e("li",[t._v("找到依赖它的所有watcher，调用update方法")]),t._v(" "),e("li",[t._v("重新调用render函数，生成新的vdom")]),t._v(" "),e("li",[t._v("patch(oldVnode, newVnode) diff 算出最小变更，nextTick 异步渲染批量更新渲染视图（减少啊DOM操作次数，提高性能）")])]),t._v(" "),e("h2",{attrs:{id:"过程-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过程-2"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),e("p",[t._v("vue的模板解析分为三步：")]),t._v(" "),e("ol",[e("li",[t._v("将template转成ast")]),t._v(" "),e("li",[t._v("optimization")]),t._v(" "),e("li",[t._v("转化成render函数")])]),t._v(" "),e("h3",{attrs:{id:"将template转成ast"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#将template转成ast"}},[t._v("#")]),t._v(" 将template转成ast")]),t._v(" "),e("p",[t._v("vue会先拿到"),e("code",[t._v("template")]),t._v("字符串，然后通过内部定义一些正则做的解析，字符串解析一部分就删除一部分，同时用一个"),e("code",[t._v("栈")]),t._v("保证标签的正常闭合。")]),t._v(" "),e("h3",{attrs:{id:"optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#optimization"}},[t._v("#")]),t._v(" optimization")]),t._v(" "),e("p",[t._v("这一步的目的是标记"),e("code",[t._v("静态节点")]),t._v("和"),e("code",[t._v("静态根节点")]),t._v("，在diff的时候可以跳过静态节点，提高性能。")]),t._v(" "),e("h3",{attrs:{id:"转化成render函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转化成render函数"}},[t._v("#")]),t._v(" 转化成render函数")]),t._v(" "),e("p",[t._v("这一步就是用"),e("code",[t._v("_c")]),t._v("、"),e("code",[t._v("_v")]),t._v("、"),e("code",[t._v("_l")]),t._v("、"),e("code",[t._v("_s")]),t._v("等方法去对ast做一个字符串的拼接，再利用"),e("code",[t._v("with")]),t._v("去组件实例上取值，然后用"),e("code",[t._v("new Function")]),t._v("把它包装成一个函数，调用这个函数就得到组件的"),e("code",[t._v("虚拟节点")]),t._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);