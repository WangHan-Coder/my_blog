---
title: 001 单例模式
date: 2021-08-01
categories:
  - 设计模式
tags:
  - JavaScript设计模式
sidebar: "auto"
---

## 定义
单例模式的定义是：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。**

实现单例模式：
```js
const Singleton = function (name) {
    this.name = name
}
Singleton.prototype.getName = function () {
    return this.name
}
Singleton.getInstance = function (name) {
    return this.instance || (this.instance = new Singleton(name))
}

const instance1 = Singleton.getInstance('zs')
const instance2 = Singleton.getInstance('lisi')
console.log(instance1 === instance2) // true
```
或者：
```js
const Singleton = function (name) {
    this.name = name
}
Singleton.prototype.getName = function () {
    return this.name
}
Singleton.getInstance = (function (name) {
    let instance = null
    return function () {
        return instance || (instance = new Singleton(name))
    }
})()
const instance1 = Singleton.getInstance('zs')
const instance2 = Singleton.getInstance('lisi')
console.log(instance1 === instance2) //true
```

## 透明的单例模式
所谓“透明”，就是这个单例类能像任何普通类一样使用（可以new），用户无感知。
```js
const CreateDiv = (function () {
    let instance
    const CreateDiv = function (html) {
        if (instance) return instance
        this.html = html
        this.init()
        return instance = this
    }
    CreateDiv.prototype.init = function () {
        const div = document.createElement('div')
        div.html = this.html
        document.body.appendChild(div)
    }
    return CreateDiv
})()

const a = new CreateDiv('a')
const b = new CreateDiv('b')
console.log(a === b) // true
```
虽然这样实现一个透明的单例类，但其中也存在一些缺点：
- 使用自执行函数和闭包封装instance，并让它返回真正的CreateDiv的构造方法，这增加了程序的复杂度，阅读性也较差
- CreateDiv函数中做了两件事情，一是保证只有一个实例，而是创建对象和执行初始化init方法，这违反了**单一职责原则**。

如果我们后面需要创建多个div，我们就需要去修改CreateDiv构造函数，让这个类从一个单例类变成一个可产生多个实例的普通类，而这种修改会带来不必要的烦恼。
> 全局变量不是单例模式   

## 用代理实现单例模式
```js
const CreateDiv = function (html) {
    this.html = html
    this.init()
}
CreateDiv.prototype.init = function () {
    const div = document.createElement('div')
    div.html = this.html
    document.body.appendChild(div)
}
const ProxySingletonCreateDiv = (function () {
    let instance
    return function (html) {
        return instance || (instance = new CreateDiv(html))
    }
})()

const a = new ProxySingletonCreateDiv('a')
const b = new ProxySingletonCreateDiv('b')
console.log(a === b) // true
```
通过引入代理类（缓存代理），将管理单例和创建初始化对象的逻辑分开，代理类ProxySingletonCreateDiv和普通类CreateDiv进行组合就可实现单例模式的效果。