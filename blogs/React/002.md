---
title: 002 React基础
date: 2021-07-08
categories:
  - React
tags:
  - React
sidebar: "auto"
---

## render函数

手动调用render函数，React不会根据最新的数据再执行一次渲染，而是会把之前render函数的结果返回给你，所以永远不要手动调用render函数，而是将render函数交给React调用。

## 为什么要采用虚拟DOM，而不是直接修改真实的DOM呢？
1. 很难跟踪状态发生的改变，不方便调试
2. 操作真实DOM性能较低，因为DOM是一个非常复杂的对象，还会引起回流和重绘。

## setState为什么设计为异步？
1. setState设计为异步，可以显著地提升性能（与MutationObserve的异步回调类似）；
  - 如果每次调用setState都进行一次更新，会导致render函数调用太频繁，会出现一些无意义的界面渲染；
  - 更好的处理方式是获取到多个更新后，进行异步的批量更新（类似Vue的nextTick）
2. 如果同步更新state，但是没有执行render函数，会导致父组件state和传入子组件的props不能保持同步，在实际开发中产生一些问题。

## setState一定是异步吗？
下面两种情况setState是同步的
1. 将setState放入到定时器中
```js
handleChange() {
  setTimeout(() => {
    this.setState({
      message: 'new message'
    })
  }, 0)
  console.log(this.state.message)
}
```
2. 原生DOM事件
```js
componentDidMount() {
  const btn = document.getElementById('btn')
  btn.addEventListener('click', () => {
    this.setState({
      message: 'new message'
    })
  })
  console.log(this.state.message)
}
```
setState是同步还是异步可以分成两种情况：
- 在组件生命周期或React合成事件中，setState是异步；
- 在setTimeout或者原生dom事件中，setState是同步。

## React为什么采用合成事件？
React不仅可以跑在浏览器上，还可以跑在在原生的手机上（React Native），为了保持一致，React将浏览器产生的DOM事件对象或原生控件的对象和自己的一些属性合并为一个**合成对象**。

## React更新机制
React渲染流程：

<img :src="$withBase('/react/react渲染流程.svg')" alt="图片加载失败">

React的更新流程：

<img :src="$withBase('/react/react更新流程.svg')" alt="图片加载失败">


React中的diff:

如果一棵树参考另外一棵树进行完全比较更新，即使采用最先进的算法，该算法的复杂度也达到了O（n³），开销过于昂贵

于是，React对算法进行优化，让复杂度降为O（n）：
- 同层节点之间的相互比较，不会跨层级比较
- 不同类型的节点，产生不同的树结构，比如老节点是div标签，新节点时p标签，会直接用新节点p及其子节点替换掉div节点及其子节点
- 通过key指定节点在不同的渲染中保持稳定 


## ref
在React的开发模式中，通常情况下不需要、也不建议直接操作原生DOM，但有些情况也确实希望对DOM进行操作：
- 管理焦点，文本选择或媒体播放
- 触发强制动画
- 集成第三方DOM库（不推荐）

ref的转发：forwardRef

函数式组件没有实例，所以不能获取到对应的组件对象，但是我们可能想要获取函数式组件中某个元素的DOM，这时候就可以用React.forwardRef了
```js
import React, { forwardRef } from 'react'
const Profile = forwardRef(function (props, ref) {
  return <p ref={ref}>Profile</p>
})
```

## 受控组件和非受控组件
- 在HTML中，表单元素（如Input、Select、Textarea）等通常会自己维护state，并根据用户输入来进行更新。
- 在React中，可变状态（mutable state）通常保存在组件的state属性中，并且只能通过setState来更新。

我们将组件的state作为表单元素的数据源，同时渲染表单的React组件还控制着用户输入过程中表单发生的操作，我们把以这种方式控制取值的表单输入元素叫做**受控组件**。

表单数据交给DOM来处理的表单组件被称为**非受控组件**。这时候需要使用ref从DOM节点中获取表单数据（不推荐）。

## 高阶组件
高阶组件（Higher-Order Components），简称HOC，**高阶组件是参数为组件，返回值为新组建的函数。**

高阶组件的编写：
```js
function higherOrderComponent(WrappedComponent) {
  class InnerComponent extends PurComponent {
    render() {
      return <WrappedComponent {...this.props}/>
    }
  }
  InnerComponent.displayName = 'Inner'
  return InnerComponent
}

```
高阶组件的调用：
```js
const EnhanceComponent = higherOrderComponent(App)
```
组件的名称问题：
- 在ES6中，类表达式中类名是可以省略的
- 组件的名称都可以通过displayName来修改

高阶组件并不是ReactApi的一部分，它是基于React的组合特性而形成的设计模式。高阶组件的作用：
1. 增强props
```js
// 使用高阶组件增强props
function withUser(WrappedComponent) {
  return props => {
    return (
      <UserContext.Consumer>
        {
          user => {
            return <WrappedComponent {...props} {...user}>
          }
        }
      </UserContext.Consumer>
    )
  }
}
```
2. 登录鉴权操作
3. 生命周期劫持

高阶组件可以进行代码的复用（替代早期的mixin）

为什么不推荐使用mixin？
- 数据来源不明确
- mixin可能会相互依赖，相互耦合，不同的mixin方法可能会相互冲突，代码维护性差
- mixin非常多，还可能再加上组件为其做的相关处理，会给代码造成滚雪球式的复杂性。

高阶组件的缺陷：
- HOC需要在源组件上进行包裹和嵌套，大量使用会让调试变得困难；
- HOC可以劫持props，在不遵守约定的情况下也可能造成冲突；

Hooks的出现，是开创性的，它解决了很多React之前存在的问题：
- this的指向问题，hoc的嵌套复杂度等

高阶组件在一些React第三方库中非常常见：
- redux中的connect
- react-router中的withRouter

## Portals的使用
某些情况下，我们希望渲染的内容独立于父组件，甚至于独立于当前挂载的DOM元素中。Portals提供了一种将子节点渲染到存在于父组件以外的DOM节点的优秀的方案：
```js
// 第一个参数child：任何可渲染的React子元素，例如一个元素，字符串或fragment
// 第二个参数container：挂载容器，比如一个DOM元素
ReactDOM.createPortal(this.props.children, document.getElementById('modal'))
```