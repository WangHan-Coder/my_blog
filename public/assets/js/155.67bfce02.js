(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{654:function(t,s,a){"use strict";a.r(s);var v=a(5),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("我们可以通过编写HTML、CSS和JavaScript文件来让浏览器展示出一个漂亮的页面，但它们是如何转化成页面的呢？")]),t._v(" "),a("p",[t._v("由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分成很多子阶段，输入的HTML经过这些子阶段后，最终输出像素。这样的一个处理流程叫做"),a("strong",[t._v("渲染流水线")]),t._v("。")]),t._v(" "),a("p",[t._v("按照渲染的时间顺序，流水线可被划分为如下几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。")]),t._v(" "),a("h2",{attrs:{id:"构建dom树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[t._v("#")]),t._v(" 构建DOM树")]),t._v(" "),a("p",[a("strong",[t._v("由于浏览器无法直接理解和使用HTML，所以需要将HTML转换成浏览器能够理解的结构-DOM树")]),t._v("。这个跟描述程序语法结构的ast（抽象语法树）类似。可以在控制台中输入“document”后回车，查看DOM结构。")]),t._v(" "),a("h2",{attrs:{id:"样式计算-recalculate-style"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#样式计算-recalculate-style"}},[t._v("#")]),t._v(" 样式计算（Recalculate Style）")]),t._v(" "),a("p",[t._v("通过样式计算，计算出DOM节点中每个元素的样式。这个阶段可分为三步：")]),t._v(" "),a("ol",[a("li",[t._v("把CSS转换为浏览器能够理解的结构")])]),t._v(" "),a("p",[t._v("CSS样式来源主要有三种：")]),t._v(" "),a("ul",[a("li",[t._v("通过link引用的外部CSS文件")]),t._v(" "),a("li",[t._v("style标签内的CSS")]),t._v(" "),a("li",[t._v("行内样式，元素style属性内嵌的CSS")])]),t._v(" "),a("p",[t._v("和HTML一样，浏览器也是无法理解这些CSS文本，所以"),a("strong",[t._v("当渲染引擎接收到CSS文本时，会执行一次转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets。")]),t._v(" 可以在控制台输入document.styleSheets查看其结构。")]),t._v(" "),a("p",[t._v("styleSheets包括了三种来源的CSS，并提供了查询和修改的功能。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("转换样式表中的属性值，使其标准化")])]),t._v(" "),a("p",[t._v("CSS中有些属性值是为了方便开发人员而设计的，但渲染引擎并不容易理解。")]),t._v(" "),a("div",{staticClass:"language-css line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" blue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2rem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("经过转化后的结果为：")]),t._v(" "),a("div",{staticClass:"language-css line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("rgb")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 0"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 255"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 28px"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 700"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("计算出DOM树种每个节点的具体样式。")])]),t._v(" "),a("p",[a("strong",[t._v("这就设计到CSS的继承规则和层叠规则了。")])]),t._v(" "),a("p",[t._v("CSS继承是指每个DOM节点都包含有父节点的样式。需要注意的是，"),a("strong",[t._v("浏览器有一组UserAgent的默认样式，如果你不提供样式，默认会使用它。")])]),t._v(" "),a("h2",{attrs:{id:"布局阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段"}},[t._v("#")]),t._v(" 布局阶段")]),t._v(" "),a("p",[t._v("布局：计算DOM树中可见元素的几何位置的过程叫做布局。Chrome在布局阶段需要完成两个任务：创建布局树和布局计算。")]),t._v(" "),a("ol",[a("li",[t._v("创建布局树")])]),t._v(" "),a("p",[t._v("DOM树中会包含一些不可见的元素，比如head标签，还有使用了display:none属性的元素，所以"),a("strong",[t._v("在显示之前，我们还要额外地构建一颗只包含可见元素的布局树。")])]),t._v(" "),a("p",[t._v("创建布局树过程：")]),t._v(" "),a("ul",[a("li",[t._v("遍历DOM树中的所有可见节点，并把这些节点加到布局树中；")]),t._v(" "),a("li",[t._v("不可见的节点会被布局树忽略掉，如head标签下面的全部内容和包含display:none属性的元素。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("布局计算")])]),t._v(" "),a("p",[t._v("有了一棵完整的布局树之后，接下来就要计算布局树节点的坐标位置了。")]),t._v(" "),a("h2",{attrs:{id:"分层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" 分层")]),t._v(" "),a("p",[t._v("生成布局树，并计算出每个元素的具体位置之后，是不是就要着手绘制页面了？")]),t._v(" "),a("p",[t._v("答案是否定的。")]),t._v(" "),a("p",[t._v("因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动、或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，"),a("strong",[t._v("渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" 正是这些图层叠加在一起构成了最终的页面图像。")]),t._v(" "),a("p",[t._v("可以通过Chrome开发者工具，选择“Layers”标签，就可以可视化页面的分层情况。")]),t._v(" "),a("p",[t._v("通常情况下，"),a("strong",[t._v("并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。")]),t._v(" 但不管怎样，最终每一个节点都会直接或者间接地从属于同一个层。")]),t._v(" "),a("p",[t._v("满足以下任意一条，渲染引擎会为这个节点创建一个单独的图层：")]),t._v(" "),a("ul",[a("li",[t._v("拥有层叠上下文属性的元素会被提升到单独的一层，比如明确定位的元素（position），定义透明的元素（opacity），使用CSS滤镜的元素（filter）等，都拥有层叠上下文。")]),t._v(" "),a("li",[t._v("需要"),a("strong",[t._v("剪裁（clip）")]),t._v(" 的地方也会创建图层")])]),t._v(" "),a("p",[t._v("剪裁：如果一个固定大小的容器里面的内容超出了容器大小，就需要裁减只展示内容的一部分。如果出现滚动条，滚动条也会被提升为单独的层。")]),t._v(" "),a("h2",{attrs:{id:"图层绘制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" 图层绘制")]),t._v(" "),a("p",[t._v("构建图层树之后，渲染引擎会对图层树中的每个图层进行绘制。")]),t._v(" "),a("p",[t._v("渲染引擎会把一个图层的绘制拆分成很多小的"),a("strong",[t._v("绘制指令")]),t._v("，然后再把这些指令按照顺序组成一个待绘制列表。每个元素的背景、前景、边框都需要单独的指令去绘制。")]),t._v(" "),a("h2",{attrs:{id:"栅格化-raster-操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栅格化-raster-操作"}},[t._v("#")]),t._v(" 栅格化（raster）操作")]),t._v(" "),a("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表"),a("strong",[t._v("提交（commit）")]),t._v(" 给合成线程。")]),t._v(" "),a("p",[t._v("合成线程是如何工作的？")]),t._v(" "),a("p",[a("strong",[t._v("视口：")]),t._v(" 通常一个页面可能很大，但用户只能看到其中一部分，我们把用户可以看到的这个部分叫做视口。")]),t._v(" "),a("p",[t._v("有时候图层可能较大，但用户只能看到视口那一部分，所以没必要一次性将所有图层全部绘制。")]),t._v(" "),a("p",[t._v("基于这个原因，"),a("strong",[t._v("合成线程会将图层划分为图块（tile），")]),t._v(" 这些图块通常是256x256或者512x512，然后"),a("strong",[t._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。")]),t._v(" 而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。")]),t._v(" "),a("p",[t._v("通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫做快速栅格化或者GPU栅格化，生成的位图被保存在GPU内存中。")]),t._v(" "),a("h2",{attrs:{id:"合成和显示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[t._v("#")]),t._v(" 合成和显示")]),t._v(" "),a("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后把该命令提交给浏览器进程。")]),t._v(" "),a("p",[t._v("浏览器进程里面有一个组件viz，它会接收合成线程发过来的DrawQuad命令，然后根据这条命令，将其页面内容绘制到内存中，最后再将内存显示到屏幕上。")]),t._v(" "),a("p",[t._v("到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。")]),t._v(" "),a("h2",{attrs:{id:"渲染流程总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程总结"}},[t._v("#")]),t._v(" 渲染流程总结")]),t._v(" "),a("p",[t._v("一个完整的渲染流程可大致总结如下：")]),t._v(" "),a("ol",[a("li",[t._v("渲染进程将HTML转化为"),a("strong",[t._v("DOM树")])]),t._v(" "),a("li",[t._v("渲染引擎将CSS样式转化为"),a("strong",[t._v("styleSheets")]),t._v("，计算出每个DOM节点的样式。")]),t._v(" "),a("li",[t._v("创建"),a("strong",[t._v("布局树")]),t._v("，并计算元素的布局信息。")]),t._v(" "),a("li",[t._v("对布局树进程分层，并生成"),a("strong",[t._v("分层树")]),t._v("。")]),t._v(" "),a("li",[t._v("为每个图层生成"),a("strong",[t._v("绘制列表")]),t._v("，并将其提交到合成线程。")]),t._v(" "),a("li",[t._v("合成线程将图层分成"),a("strong",[t._v("图块")]),t._v("，并在"),a("strong",[t._v("光栅化线程池")]),t._v("中将图块转换成位图。")]),t._v(" "),a("li",[t._v("合成线程发送绘制图块命令"),a("strong",[t._v("DrawQuad")]),t._v("给浏览器进程。")]),t._v(" "),a("li",[t._v("浏览器进程根据DrawQuad消息"),a("strong",[t._v("生成页面")]),t._v("，并显示到显示器上。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);