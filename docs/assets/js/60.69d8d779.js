(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{561:function(e,t,v){"use strict";v.r(t);var _=v(5),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[e._v("vue提供了两种编译版本，一种是"),v("code",[e._v("Runtime-Compiler")]),e._v("，还有一种是"),v("code",[e._v("Runtime-only")]),e._v("，前者会多提供"),v("code",[e._v("compiler")]),e._v("功能，也就是支持"),v("code",[e._v("template")]),e._v("写法。也就是我们可以在组件对象中写"),v("code",[e._v("template:<div>"+e._s(e.a)+"</div>")]),e._v("，然后vue内部会把template转化为"),v("code",[e._v("render函数")]),e._v("，这个过程就是"),v("code",[e._v("模板编译")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"模板编译"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模板编译"}},[e._v("#")]),e._v(" 模板编译")]),e._v(" "),v("h3",{attrs:{id:"原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[e._v("#")]),e._v(" 原因")]),e._v(" "),v("ul",[v("li",[e._v("模板不是html，有指令、插值、JS表达式，能实现判断、循环")]),e._v(" "),v("li",[e._v("html是标签语言，只有JS才能实现判断、循环（图灵完备的，能实现我们日常的业务逻辑，能实现顺序执行、循环和判断）")]),e._v(" "),v("li",[e._v("因此，模板一定是转换为某种JS代码，即模板编译")])]),e._v(" "),v("h3",{attrs:{id:"过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),v("ul",[v("li",[e._v("width语法")]),e._v(" "),v("li",[e._v("vue template complier将模板编译为render函数")]),e._v(" "),v("li",[e._v("执行render函数生成vnode")]),e._v(" "),v("li",[e._v("基于vnode再执行patch和diff")]),e._v(" "),v("li",[e._v("使用vue-loader，会在开发环境下编译模板")])]),e._v(" "),v("h2",{attrs:{id:"初次渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初次渲染"}},[e._v("#")]),e._v(" 初次渲染")]),e._v(" "),v("ul",[v("li",[e._v("initState数据劫持，添加getter和setter")]),e._v(" "),v("li",[e._v("挂载时将模板编译成render函数（或在开发环境下用vue-loader完成）")]),e._v(" "),v("li",[e._v("调用render函数生成vdom，收集依赖")]),e._v(" "),v("li",[e._v("patch(elm, vnode)渲染到页面上")])]),e._v(" "),v("h2",{attrs:{id:"更新流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更新流程"}},[e._v("#")]),e._v(" 更新流程")]),e._v(" "),v("ul",[v("li",[e._v("修改数据，触发setter")]),e._v(" "),v("li",[e._v("找到依赖它的所有watcher，调用update方法")]),e._v(" "),v("li",[e._v("重新调用render函数，生成新的vdom")]),e._v(" "),v("li",[e._v("patch(oldVnode, newVnode) diff 算出最小变更，nextTick 异步渲染批量更新渲染视图（减少啊DOM操作次数，提高性能）")])]),e._v(" "),v("h2",{attrs:{id:"过程-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过程-2"}},[e._v("#")]),e._v(" 过程")]),e._v(" "),v("p",[e._v("vue的模板解析分为三步：")]),e._v(" "),v("ol",[v("li",[e._v("将template转成ast")]),e._v(" "),v("li",[e._v("optimization")]),e._v(" "),v("li",[e._v("转化成render函数")])]),e._v(" "),v("h3",{attrs:{id:"将template转成ast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#将template转成ast"}},[e._v("#")]),e._v(" 将template转成ast")]),e._v(" "),v("p",[e._v("vue会先拿到"),v("code",[e._v("template")]),e._v("字符串，然后通过内部定义一些正则做的解析，字符串解析一部分就删除一部分，同时用一个"),v("code",[e._v("栈")]),e._v("保证标签的正常闭合。")]),e._v(" "),v("h3",{attrs:{id:"optimization"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#optimization"}},[e._v("#")]),e._v(" optimization")]),e._v(" "),v("p",[e._v("这一步的目的是标记"),v("code",[e._v("静态节点")]),e._v("和"),v("code",[e._v("静态根节点")]),e._v("，在diff的时候可以跳过静态节点，提高性能。")]),e._v(" "),v("h3",{attrs:{id:"转化成render函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#转化成render函数"}},[e._v("#")]),e._v(" 转化成render函数")]),e._v(" "),v("p",[e._v("这一步就是用"),v("code",[e._v("_c")]),e._v("、"),v("code",[e._v("_v")]),e._v("、"),v("code",[e._v("_l")]),e._v("、"),v("code",[e._v("_s")]),e._v("等方法去对ast做一个字符串的拼接，再利用"),v("code",[e._v("with")]),e._v("去组件实例上取值，然后用"),v("code",[e._v("new Function")]),e._v("把它包装成一个函数，调用这个函数就得到组件的"),v("code",[e._v("虚拟节点")]),e._v("。")])])}),[],!1,null,null,null);t.default=a.exports}}]);